<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"C__Users_Dario Garcia Moya_Projects_diyJs_diy_diy.js.html":{"id":"C__Users_Dario Garcia Moya_Projects_diyJs_diy_diy.js.html","title":"Source: C:/Users/Dario Garcia Moya/Projects/diyJs/diy/diy.js","body":" DocStrap Namespaces DIY Source: C:/Users/Dario Garcia Moya/Projects/diyJs/diy/diy.js /*global DIY: true*/ /* exported DIY */ /** * @namespace */ var DIY = (function (window) { var jsPath = '', composeScriptUrl = function (namespace) { var parts = namespace.split('.'), constructorName = parts.pop(); parts.shift(); return jsPath + parts.join('/') + '/' + constructorNameToFileName(constructorName) + '.js'; }, constructorNameToFileName = function (name) { return name.charAt(0).toLowerCase() + name.substr(1); }, getScript = function (namespace) { var script = document.createElement('script'), src = composeScriptUrl.call(this, namespace); script.setAttribute('type', 'text/javascript'); script.setAttribute('src', src); return script; }, isConstructorDefined = function (namespace) { var parts = namespace.split('.'), root = window[parts.shift()], currentPart, i; for (i = 0; i &lt; parts.length; i++) { currentPart = parts[i]; if (!root[currentPart]) { return false; } root = root[currentPart]; } return true; }, loadDependencies = function (requires) { var i, docfrag = document.createDocumentFragment(), head = document.getElementsByTagName('head')[0]; for (i = 0; i &lt; requires.length; i++) { if (!isConstructorDefined(requires[i])) { docfrag.appendChild(getScript.call(this, requires[i])); } } head.appendChild(docfrag); }, /** * Define your namespace with this method. &lt;br /&gt; * * NOTE: you need to init the framework first, calling {DYI.init} init() &lt;br /&gt; * * In this version you can: &lt;br /&gt; * * Define classes &lt;br /&gt; * * Use inheritance &lt;br /&gt; * * Lazy load of dependencies. &lt;br /&gt; * * Polymorphism &lt;br /&gt; * * Define a singleton class ( inheritance is not supported here yet ) &lt;br /&gt; * * @example * &lt;caption&gt;The regular way to define a constructor would be:&lt;/caption&gt; * * DIY.define('MYAPP.MyNameSpace', {}, function () { * var myPrivatevar; * * this.initialize = function () { * myPrivatevar = 1; * }; * * this.myPublicMethod = function () { * return myPrivatevar; * }; * }); * @example * &lt;caption&gt;you should always initialize you class with the initialize method and * not directly in the constructor, ie: &lt;/caption&gt; * * // Very bad. Init config objec should not be passed here * DIY.define('MYAPP.MyNameSpace', {}, function (cfg) { * var myPrivatevar = 1; // Bad * * // Good. You should pass you config object into the initialize method * this.initialize = function (cfg) { * myPrivatevar = 1; // Good * }; * * this.myPublicMethod = function () { * return myPrivatevar; * }: * }); * @example * &lt;caption&gt;initialize method is mandatory, unless your class inherits from a class * which already has the initilize method, then the child class will be initialized with * the parent initialize method. &lt;br /&gt; * This is private and it should not be called from outside. It is there for initialize * purposes only.&lt;/br&gt;&lt;/br&gt;&lt;/br&gt; * * If the constructor has some dependencies:&lt;/caption&gt; * * DIY.define('MYAPP.MyNameSpace', { * requires: [ * 'MYAPP.module.myModuleNeeded1', * 'MYAPP.module.myModuleNeeded2' * ] * }, function () { * var myPrivatevar; * * this.initialize = function () { * myPrivatevar = 1; * }; * }); * * * * @example * &lt;caption&gt;This will load the dependencies, if not yet loaded, asyncronously &lt;/br&gt;&lt;/br&gt;&lt;/br&gt; * * If the constructor inherits from anyone else: * &lt;/caption&gt; * * DIY.define('MYAPP.MyNameSpace', { * extend: 'MYAPP.module.ParentModule' * }, function () { * var myPrivatevar; * * this.initialize = function () { * myPrivatevar = 1; * }; * }); * * @example * &lt;caption&gt;This will add one instance of &quot;ParentModule&quot; to the prototype of MyNameSpace &lt;/br&gt; * NOTE: In this version the parent namespace should be already loaded. * There not load lazy loading implemented for parent constructors &lt;/br&gt;&lt;/br&gt;&lt;/br&gt; * * Parent constructor will be initialized with the arguments passed in to the child constructor, * as it is supposed to be, i.e * &lt;/caption&gt; * * DIY.define('MYAPP.module.ParentModule', {}, function () { * this.myParentVar; * * this.initialize = function (cfg) { * this.myParentVar = cfg.private; * }; * }); * * DIY.define('MYAPP.module.MyNameSpace', { * extend: 'MYAPP.module.ParentModule' * }, function () { * this.myPublicMethod = function () { * return this.myParentVar; * }; * }); * * * var myChildInstance = new MYAPP.module.MyNameSpace({ * private: 'foo' * }); * * * myChildInstance.myPublicMethod(); * * @example * &lt;caption&gt; * Polymorphism ist allowed, you just have to call this.parentClass.methodName(), i.e. * &lt;/caption&gt; * * DIY.define('MYAPP.module.ParentModule', {}, function () { * var myPrivatevar; * * this.initialize = function (cfg) { * myPrivatevar = cfg.private; * }; * * this.myPublicMethod = function () { * return myPrivatevar; * }; * }); * * DIY.define('MYAPP.module.MyNameSpace', { * extend: 'MYAPP.module.ParentModule' * }, function () { * this.myPublicMethod = function () { * return this.parentClass.myPublicMethod() + ' and bar'; * }; * }); * * * var myChildInstance = new MYAPP.module.MyNameSpace({ * private: 'foo' * }); * * * myChildInstance.myPublicMethod(); // this will return 'foo and bar' * * * @example * &lt;caption&gt;You can also define a singleton class, i.e.&lt;/caption&gt; * * DIY.define('MYAPP.singletonClass', { * singleton: true * }, function () { * this.myPublicMethod = function () { * return 'my singleton object'; * }; * }); * * @example * &lt;caption&gt;then you will be able to access to the public methods like this&lt;/caption&gt; * * var mySingletonInstance = new MYAPP.singletonClass(); * mySingletonInstance.myPublicMethod(); // this will return 'my singleton object' * * @example * &lt;caption&gt;Remember that it will only create the instance the first time you call it. * The following times it will return the same instance. * &lt;/caption&gt; * * var mySingletonInstance = new MYAPP.singletonClass(); * var mySingletonInstance2 = new MYAPP.singletonClass(); * mySingletonInstance === mySingletonInstance2; // true * * @example * &lt;caption&gt; You can add a initialize method to a singleton class if you want. * This is not mandatory but this is usefull when you want to initialize a singleton * class or pass dependencies. * &lt;/caption&gt; * * DIY.define('MYAPP.singletonClass', { * singleton: true * }, function () { * var dependency; * * this.initialize = function (cfg) { * dependency = cfg.dependency; * }; * this.myPublicMethod = function () { * return dependency; * }; * }); * * var mySingletonInstance = new MYAPP.singletonClass({ * dependency: 'hey' * }); * * mySingletonInstance.myPublicMethod();// hey * * @param {String} namespace * @param {Object} config Some configurations for the definition of the constructor * @param {Function} config.extend. This parameter is mandatory. * If you dont need inheritance, just pass null, empty string or undefined. * @param {Array} config.requires. Array with the modules which are required. * If you dont need dependencies, just pass an empty array * @param {Function} body. Constructor code * @memberof DIY */ define = function (namespace, config, body) { var parts = namespace.split('.'), appName = parts[0], requires = config.requires; if (!window[appName]) { window[appName] = {}; } if (requires &amp;&amp; requires.length &gt; 0) { loadDependencies.call(this, requires); } createNamespace.call(this, parts, body, config); }, createNamespace = function (parts, body, config) { var i, length = parts.length, current, root = window[parts[0]]; for (i = 1; i &lt; length; i++) { current = parts[i]; if (i &lt; length - 1) { root[current] = !root[current] ? {} : root[current]; root = root[current]; } } if (root[current]) { throw 'The constructor &quot;' + parts.join('.') + '&quot; was already defined. Please check.'; } root[current] = getClass.call(this, body, config.singleton, config.extend); }, findConstructor = function (namespace) { var parts = namespace.split('.'), root = window[parts.shift()], currentPart, i; for (i = 0; i &lt; parts.length; i++) { currentPart = parts[i]; if (!root[currentPart]) { return false; } root = root[currentPart]; } return root; }, isThereAParentConstructor = function (constructor) { return !!constructor; }, getClass = function (Constructor, singleton, parent) { if (singleton) { return getSingletonObject.call(this, Constructor, parent); } return getConstructor.call(this, Constructor, parent); }, getSingletonObject = function (Constructor, parent) { var singletonBorrowedConstructor; if (isThereAParentConstructor.call(this, parent)) { throw 'Inheritance for singleton objects is not supported.'; } singletonBorrowedConstructor = function () { var instance = singletonBorrowedConstructor.prototype.instance; if (instance) { return instance; } instance = new Constructor(); if (instance.initialize) { instance.initialize.apply(instance, arguments); } singletonBorrowedConstructor.prototype.instance = instance; return singletonBorrowedConstructor.prototype.instance; }; return singletonBorrowedConstructor; }, getConstructor = function (Constructor, parent) { if (isThereAParentConstructor.call(this, parent)) { if (isConstructorDefined.call(this, parent)) { return inherit(Constructor, findConstructor.call(this, parent)); } else { throw 'Parent constructor should be loaded manually to inherit from it.'; } } else { return getBorrowedConstructor.call(this, Constructor); } }, shouldInitialize = function (config) { return !config || !config.__notInitialize; }, getBorrowedConstructor = function (Constructor) { var borrowedConstructor = function () { if (!this.initialize) { throw 'Error. Class does not have initialize method'; } // when this constructor is called from the inherits method, // initialize method should not be called, since the constructor // is nt being initialized yet. if (shouldInitialize.call(this, arguments[0])) { this.initialize.apply(this, arguments); } }; borrowedConstructor.prototype = new Constructor(); return borrowedConstructor; }, inherit = function (Child, Parent) { var borrowedConstructor, instance = new Parent({ __notInitialize: true }); Child.prototype = instance; borrowedConstructor = getBorrowedConstructor.call(this, Child); borrowedConstructor.prototype.parentClass = instance; return borrowedConstructor; }, /** * You need to call this method at the beggining of you app with the proper config object * otherwise you wont be able to use the framework. * @param {Object} cfg * @param {String} cfg.jsPath Path to the place where your js modules are placed. i.e. * &lt;pre&gt; * jsPath: 'http://localhost/assets/js/src/' * &lt;/pre&gt; * @memberof DIY */ init = function (cfg) { this.define = define; jsPath = cfg.jsPath; }; return { define: function () { throw 'App not initialized. Please call DIY.init with proper params'; }, init: init }; })(window); × Search results Close "},"namespaces.list.html":{"id":"namespaces.list.html","title":"Namespaces","body":" DocStrap Namespaces DIY Namespaces Namespaces DIY × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" DocStrap Namespaces DIY × Search results Close "},"DIY.html":{"id":"DIY.html","title":"Namespace: DIY","body":" DocStrap Namespaces DIY Namespace: DIY DIY Source: C:/Users/Dario Garcia Moya/Projects/diyJs/diy/diy.js, line 7 Methods &lt;static&gt; define(namespace, config) Define your namespace with this method. NOTE: you need to init the framework first, calling {DYI.init} init() In this version you can: Define classes Use inheritance Lazy load of dependencies. Polymorphism Define a singleton class ( inheritance is not supported here yet ) Parameters: Name Type Description namespace String config Object Some configurations for the definition of the constructor Properties Name Type Description extend. function This parameter is mandatory. If you dont need inheritance, just pass null, empty string or undefined. requires. Array Array with the modules which are required. If you dont need dependencies, just pass an empty array body. function Constructor code Source: C:/Users/Dario Garcia Moya/Projects/diyJs/diy/diy.js, line 277 Examples The regular way to define a constructor would be: DIY.define('MYAPP.MyNameSpace', {}, function () { var myPrivatevar; this.initialize = function () { myPrivatevar = 1; }; this.myPublicMethod = function () { return myPrivatevar; }; }); you should always initialize you class with the initialize method and not directly in the constructor, ie: // Very bad. Init config objec should not be passed here DIY.define('MYAPP.MyNameSpace', {}, function (cfg) { var myPrivatevar = 1; // Bad // Good. You should pass you config object into the initialize method this.initialize = function (cfg) { myPrivatevar = 1; // Good }; this.myPublicMethod = function () { return myPrivatevar; }: }); initialize method is mandatory, unless your class inherits from a class which already has the initilize method, then the child class will be initialized with the parent initialize method. This is private and it should not be called from outside. It is there for initialize purposes only. If the constructor has some dependencies: DIY.define('MYAPP.MyNameSpace', { requires: [ 'MYAPP.module.myModuleNeeded1', 'MYAPP.module.myModuleNeeded2' ] }, function () { var myPrivatevar; this.initialize = function () { myPrivatevar = 1; }; }); This will load the dependencies, if not yet loaded, asyncronously If the constructor inherits from anyone else: DIY.define('MYAPP.MyNameSpace', { extend: 'MYAPP.module.ParentModule' }, function () { var myPrivatevar; this.initialize = function () { myPrivatevar = 1; }; }); This will add one instance of &quot;ParentModule&quot; to the prototype of MyNameSpace NOTE: In this version the parent namespace should be already loaded. There not load lazy loading implemented for parent constructors Parent constructor will be initialized with the arguments passed in to the child constructor, as it is supposed to be, i.e DIY.define('MYAPP.module.ParentModule', {}, function () { this.myParentVar; this.initialize = function (cfg) { this.myParentVar = cfg.private; }; }); DIY.define('MYAPP.module.MyNameSpace', { extend: 'MYAPP.module.ParentModule' }, function () { this.myPublicMethod = function () { return this.myParentVar; }; }); var myChildInstance = new MYAPP.module.MyNameSpace({ private: 'foo' }); myChildInstance.myPublicMethod(); Polymorphism ist allowed, you just have to call this.parentClass.methodName(), i.e. DIY.define('MYAPP.module.ParentModule', {}, function () { var myPrivatevar; this.initialize = function (cfg) { myPrivatevar = cfg.private; }; this.myPublicMethod = function () { return myPrivatevar; }; }); DIY.define('MYAPP.module.MyNameSpace', { extend: 'MYAPP.module.ParentModule' }, function () { this.myPublicMethod = function () { return this.parentClass.myPublicMethod() + ' and bar'; }; }); var myChildInstance = new MYAPP.module.MyNameSpace({ private: 'foo' }); myChildInstance.myPublicMethod(); // this will return 'foo and bar' You can also define a singleton class, i.e. DIY.define('MYAPP.singletonClass', { singleton: true }, function () { this.myPublicMethod = function () { return 'my singleton object'; }; }); then you will be able to access to the public methods like this var mySingletonInstance = new MYAPP.singletonClass(); mySingletonInstance.myPublicMethod(); // this will return 'my singleton object' Remember that it will only create the instance the first time you call it. The following times it will return the same instance. var mySingletonInstance = new MYAPP.singletonClass(); var mySingletonInstance2 = new MYAPP.singletonClass(); mySingletonInstance === mySingletonInstance2; // true You can add a initialize method to a singleton class if you want. This is not mandatory but this is usefull when you want to initialize a singleton class or pass dependencies. DIY.define('MYAPP.singletonClass', { singleton: true }, function () { var dependency; this.initialize = function (cfg) { dependency = cfg.dependency; }; this.myPublicMethod = function () { return dependency; }; }); var mySingletonInstance = new MYAPP.singletonClass({ dependency: 'hey' }); mySingletonInstance.myPublicMethod();// hey &lt;static&gt; init(cfg) You need to call this method at the beggining of you app with the proper config object otherwise you wont be able to use the framework. Parameters: Name Type Description cfg Object Properties Name Type Description jsPath String Path to the place where your js modules are placed. i.e. jsPath: 'http://localhost/assets/js/src/' Source: C:/Users/Dario Garcia Moya/Projects/diyJs/diy/diy.js, line 429 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
