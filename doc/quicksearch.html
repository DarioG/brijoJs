<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"C__Users_dgarciamoya_workspaces_diyJs_diy_diy.js.html":{"id":"C__Users_dgarciamoya_workspaces_diyJs_diy_diy.js.html","title":"Source: C:/Users/dgarciamoya/workspaces/diyJs/diy/diy.js","body":" DocStrap Namespaces DIY Source: C:/Users/dgarciamoya/workspaces/diyJs/diy/diy.js /*global DIY: true*/ /* exported DIY */ /** * @namespace */ var DIY = (function (window) { var jsPath = '', composeScriptUrl = function (namespace) { var parts = namespace.split('.'), constructorName = parts.pop(); parts.shift(); return jsPath + parts.join('/') + '/' + constructorNameToFileName(constructorName) + '.js'; }, constructorNameToFileName = function (name) { return name.charAt(0).toLowerCase() + name.substr(1); }, getScript = function (namespace) { var script = document.createElement('script'), src = composeScriptUrl.call(this, namespace); script.setAttribute('type', 'text/javascript'); script.setAttribute('src', src); return script; }, isConstructorDefined = function (namespace) { var parts = namespace.split('.'), root = window[parts.shift()], currentPart, i; for (i = 0; i &lt; parts.length; i++) { currentPart = parts[i]; if (!root[currentPart]) { return false; } root = root[currentPart]; } return true; }, loadDependencies = function (requires) { var i, docfrag = document.createDocumentFragment(), head = document.getElementsByTagName('head')[0]; for (i = 0; i &lt; requires.length; i++) { if (!isConstructorDefined(requires[i])) { docfrag.appendChild(getScript.call(this, requires[i])); } } head.appendChild(docfrag); }, /** * Define your namespace with this method. &lt;br /&gt; * * NOTE: you need to init the framework first, calling {DYI.init} init() &lt;br /&gt; * * In this version you can: &lt;br /&gt; * * Define classes &lt;br /&gt; * * Use inheritance &lt;br /&gt; * * Lazy load of dependencies. &lt;br /&gt; * * Polymorphism &lt;br /&gt; * * Define a singleton class ( inheritance is not supported here yet ) &lt;br /&gt; * * @example * &lt;caption&gt;The regular way to define a constructor would be:&lt;/caption&gt; * * DIY.define('MyNameSpace', {}, function () { * var myPrivatevar = 1; * * this.myPublicMethod = function () { * return myPrivatevar; * }: * }); * @example * &lt;caption&gt;If the constructor has some dependencies:&lt;/caption&gt; * * DIY.define('MyNameSpace', { * requires: [ * 'MYAPP.module.myModuleNeeded1', * 'MYAPP.module.myModuleNeeded2' * ] * }, function () { * var myPrivatevar = 1; * * this.myPublicMethod = function () { * return myPrivatevar; * }; * }); * * * * @example * &lt;caption&gt;This will load the dependencies, if not yet loaded, asyncronously &lt;/br&gt;&lt;/br&gt;&lt;/br&gt; * * If the constructor inherits from anyone else: * &lt;/caption&gt; * * DIY.define('MyNameSpace', { * extend: 'MYAPP.module.ParentModule' * }, function () { * var myPrivatevar = 1; * * this.myPublicMethod = function () { * return myPrivatevar; * }; * }); * * @example * &lt;caption&gt;This will add one instance of &quot;ParentModule&quot; to the prototype of MyNameSpace &lt;/br&gt; * NOTE: In this version the parent namespace should be already loaded. * There not load lazy loading implemented for parent constructors &lt;/br&gt;&lt;/br&gt;&lt;/br&gt; * * Parent constructor will be initialized with the arguments passed in to the child constructor, * as it is supposed to be, i.e * &lt;/caption&gt; * * DIY.define('ParentModule', {}, function (cfg) { * var myPrivatevar = cfg.private; * }); * * DIY.define('MyNameSpace', { * extend: 'MYAPP.module.ParentModule' * }, function () { * this.myPublicMethod = function () { * return myPrivatevar; * }; * }); * * * var myChildInstance = MyNameSpace({ * private: 'foo' * }); * * * myChildInstance.myPublicMethod(); // this will return 'foo' * * @example * &lt;caption&gt; * Polymorphism ist allowed, you just have to call this.parentClass.methodName(), i.e. * &lt;/caption&gt; * * DIY.define('ParentModule', {}, function (cfg) { * var myPrivatevar = cfg.private; * * this.myPublicMethod = function () { * return myPrivatevar; * }; * }); * * DIY.define('MyNameSpace', { * extend: 'MYAPP.module.ParentModule' * }, function () { * this.myPublicMethod = function () { * return this.parentClass.myPublicMethod() + ' and bar'; * }; * }); * * * var myChildInstance = MyNameSpace({ * private: 'foo' * }); * * * myChildInstance.myPublicMethod(); // this will return 'foo and bar' * * * @example * &lt;caption&gt;You can also define a singleton class, i.e.&lt;/caption&gt; * * DIY.define('singletonClass', { * singleton: true * }, function () { * this.myPublicMethod = function () { * return 'my singleton object'; * }; * }); * * @example * &lt;caption&gt;then you will be able to access to the public methods directly like this&lt;/caption&gt; * * singletonClass.myPublicMethod(); // this will return 'my singleton object' * * @example * &lt;caption&gt; * otherwise if you try to instanciate again with new, it will throw an exception * &lt;/caption&gt; * * var myNewInstance = new singletonClass(); // This will throw * * @param {String} namespace * @param {Object} config Some configurations for the definition of the constructor * @param {Function} config.extend. This parameter is mandatory. * If you dont need inheritance, just pass null, empty string or undefined. * @param {Array} config.requires. Array with the modules which are required. * If you dont need dependencies, just pass an empty array * @param {Function} body. Constructor code * @memberof DIY */ define = function (namespace, config, body) { var parts = namespace.split('.'), appName = parts[0], requires = config.requires; if (!window[appName]) { window[appName] = {}; } if (requires &amp;&amp; requires.length &gt; 0) { loadDependencies.call(this, requires); } createNamespace.call(this, parts, body, config); }, createNamespace = function (parts, body, config) { var i, length = parts.length, current, root = window[parts[0]]; for (i = 1; i &lt; length; i++) { current = parts[i]; if (i &lt; length - 1) { root[current] = !root[current] ? {} : root[current]; root = root[current]; } } if (root[current]) { throw 'The constructor &quot;' + parts.join('.') + '&quot; was already defined. Please check.'; } root[current] = getClass.call(this, body, config.singleton, config.extend); }, findConstructor = function (namespace) { var parts = namespace.split('.'), root = window[parts.shift()], currentPart, i; for (i = 0; i &lt; parts.length; i++) { currentPart = parts[i]; if (!root[currentPart]) { return false; } root = root[currentPart]; } return root; }, inherit = function (child, Parent) { var borrowedConstructor = function () { Parent.apply(this, arguments); child.apply(this, arguments); }, instance = new Parent(); borrowedConstructor.prototype = instance; borrowedConstructor.prototype.parentClass = instance; return borrowedConstructor; }, isThereAParentConstructor = function (constructor) { return !!constructor; }, getClass = function (Constructor, singleton, parent) { if (singleton) { return getSingletonObject.call(this, Constructor, parent); } return getConstructor.call(this, Constructor, parent); }, getSingletonObject = function (Constructor, parent) { if (isThereAParentConstructor.call(this, parent)) { throw 'Inheritance for singleton objects is not supported.'; } return new Constructor(); }, getConstructor = function (Constructor, parent) { if (isThereAParentConstructor.call(this, parent)) { if (isConstructorDefined.call(this, parent)) { return inherit(Constructor, findConstructor.call(this, parent)); } else { throw 'Parent constructor should be loaded manually to inherit from it.'; } } else { return Constructor; } }, /** * You need to call this method at the beggining of you app with the proper config object * otherwise you wont be able to use the framework. * @param {Object} cfg * @param {String} cfg.jsPath Path to the place where your js modules are placed. i.e. * &lt;pre&gt; * jsPath: 'http://localhost/assets/js/src/' * &lt;/pre&gt; * @memberof DIY */ init = function (cfg) { this.define = define; jsPath = cfg.jsPath; }; return { define: function () { throw 'App not initialized. Please call DIY.init with proper params'; }, init: init }; })(window); × Search results Close "},"namespaces.list.html":{"id":"namespaces.list.html","title":"Namespaces","body":" DocStrap Namespaces DIY Namespaces Namespaces DIY × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" DocStrap Namespaces DIY × Search results Close "},"DIY.html":{"id":"DIY.html","title":"Namespace: DIY","body":" DocStrap Namespaces DIY Namespace: DIY DIY Source: C:/Users/dgarciamoya/workspaces/diyJs/diy/diy.js, line 7 Methods &lt;static&gt; define(namespace, config) Define your namespace with this method. NOTE: you need to init the framework first, calling {DYI.init} init() In this version you can: Define classes Use inheritance Lazy load of dependencies. Polymorphism Define a singleton class ( inheritance is not supported here yet ) Parameters: Name Type Description namespace String config Object Some configurations for the definition of the constructor Properties Name Type Description extend. function This parameter is mandatory. If you dont need inheritance, just pass null, empty string or undefined. requires. Array Array with the modules which are required. If you dont need dependencies, just pass an empty array body. function Constructor code Source: C:/Users/dgarciamoya/workspaces/diyJs/diy/diy.js, line 213 Examples The regular way to define a constructor would be: DIY.define('MyNameSpace', {}, function () { var myPrivatevar = 1; this.myPublicMethod = function () { return myPrivatevar; }: }); If the constructor has some dependencies: DIY.define('MyNameSpace', { requires: [ 'MYAPP.module.myModuleNeeded1', 'MYAPP.module.myModuleNeeded2' ] }, function () { var myPrivatevar = 1; this.myPublicMethod = function () { return myPrivatevar; }; }); This will load the dependencies, if not yet loaded, asyncronously If the constructor inherits from anyone else: DIY.define('MyNameSpace', { extend: 'MYAPP.module.ParentModule' }, function () { var myPrivatevar = 1; this.myPublicMethod = function () { return myPrivatevar; }; }); This will add one instance of &quot;ParentModule&quot; to the prototype of MyNameSpace NOTE: In this version the parent namespace should be already loaded. There not load lazy loading implemented for parent constructors Parent constructor will be initialized with the arguments passed in to the child constructor, as it is supposed to be, i.e DIY.define('ParentModule', {}, function (cfg) { var myPrivatevar = cfg.private; }); DIY.define('MyNameSpace', { extend: 'MYAPP.module.ParentModule' }, function () { this.myPublicMethod = function () { return myPrivatevar; }; }); var myChildInstance = MyNameSpace({ private: 'foo' }); myChildInstance.myPublicMethod(); // this will return 'foo' Polymorphism ist allowed, you just have to call this.parentClass.methodName(), i.e. DIY.define('ParentModule', {}, function (cfg) { var myPrivatevar = cfg.private; this.myPublicMethod = function () { return myPrivatevar; }; }); DIY.define('MyNameSpace', { extend: 'MYAPP.module.ParentModule' }, function () { this.myPublicMethod = function () { return this.parentClass.myPublicMethod() + ' and bar'; }; }); var myChildInstance = MyNameSpace({ private: 'foo' }); myChildInstance.myPublicMethod(); // this will return 'foo and bar' You can also define a singleton class, i.e. DIY.define('singletonClass', { singleton: true }, function () { this.myPublicMethod = function () { return 'my singleton object'; }; }); then you will be able to access to the public methods directly like this singletonClass.myPublicMethod(); // this will return 'my singleton object' otherwise if you try to instanciate again with new, it will throw an exception var myNewInstance = new singletonClass(); // This will throw &lt;static&gt; init(cfg) You need to call this method at the beggining of you app with the proper config object otherwise you wont be able to use the framework. Parameters: Name Type Description cfg Object Properties Name Type Description jsPath String Path to the place where your js modules are placed. i.e. jsPath: 'http://localhost/assets/js/src/' Source: C:/Users/dgarciamoya/workspaces/diyJs/diy/diy.js, line 326 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
